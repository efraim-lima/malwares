import os
import sys

current_dir = os.path.dirname(os.path.abspath(__file__))
parent_dir = os.path.dirname(current_dir)
sys.path.append(parent_dir)
# Certifique-se de que o diretório do projeto esteja no sys.path
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

import cv2
import datetime
from modules.database import collection_image, hour, today
import time
import atexit
import psutil

global current_time
current_time = time.time()  # Inicialize a variável current_time

def clear_terminal():
    """Limpa o terminal."""
  #  os.system('cls' if os.name == 'nt' else 'clear')

def logs_task():
    for _ in range(10):
        # Simulação de tarefa de áudio
        time.sleep(1)
        cpu_percent = psutil.cpu_percent()
        memory_percent = psutil.virtual_memory().percent
        print(f"Uso de CPU: {cpu_percent}%")
        print(f"Uso de memória: {memory_percent}%")
        clear_terminal()
    
def is_camera_active(camera_index=0):
    # Tente abrir a câmera
    cap = cv2.VideoCapture(camera_index)

    while(True):
        # Capture frame-by-frame
        ret, frame = cap.read()

        if cap.isOpened():
            print("Webcam off-line.")
            return None
        else:
            return cap


# Função para capturar e salvar imagens
def save_image(frame):
    # Gerar o nome do arquivo com base na data e hora atual
    capture_time = datetime.datetime.now()
    filename = f"image_{capture_time.strftime('%Y%m%d_%H%M%S')}.jpg"
    
    # Salvar a imagem no formato JPEG para avaliação posterior
    cv2.imwrite(filename, frame)
    
# Função para capturar imagens da câmera
def images():
    cap = is_camera_active()

    if cap is None:
        print("Câmera não encontrada ou não está funcionando. O aplicativo não ativará a câmera.")
        return

    def exit_handler():
        cap.release()
        cv2.destroyAllWindows()

    atexit.register(exit_handler)

    while True:
        ret, frame = cap.read()
        if not ret:
            print("Not ret. Verificando em segundo plano...")
            time.sleep(5)  # Aguarde um tempo antes de verificar novamente
            continue  # Continue a próxima iteração sem gravar
        
        now = time.time()
        global current_time
        
        if now - current_time >= 30:
            # Salvar a imagem no banco de dados
            capture_time = datetime.datetime.now()
            name = capture_time.strftime("%Y%m%d_%H%M%S")
            tag = capture_time.strftime("%Y%m%d")
            filename = f"image_{name}.jpg"
            
            _, jpeg_image = cv2.imencode(".jpg", frame)
            jpeg_image_data = jpeg_image.tobytes()
            
            image_data = {
                "date": today,
                "hour": hour,
                "filename": filename, 
                "image": jpeg_image_data, 
                "tag": tag
            }
            collection_image.insert_one(image_data)

            # Salvar a imagem localmente para visualização
            save_image(frame)
            
            current_time = now  # Atualize a variável current_time para o novo valor de 'now'

# Iniciar a captura de imagens

def main():    
    try:
        images()
    except Exception as e:
        print(f"Erro: {e}")

if __name__ == "__main__":
    main()
